+---------+
|Resources|
+---------+
#https://darksim905.com/~sim/reverse-engineering-notes.txt
This list is unorganized...

Download this:
https://bluesoul.me/practical-malware-analysis-starter-kit/
https://www.reddit.com/r/Malware/comments/4jcrq7/just_released_the_practical_malware_analysis/
^ password is malware


https://remnux.org/
https://vimeo.com/dguido/videos
https://www.reddit.com/r/ReverseEngineering/comments/12ajwc/how_to_start_out_in_reverse_engineering/
https://vimeo.com/148320460

https://www.linkedin.com/in/aaron-portnoy-26368b4b
^^see his talks^^ -> aportnoy

https://reverseengineering.stackexchange.com/questions/6801/general-consensus-on-lenas-tutorials
https://www.reddit.com/r/ReverseEngineering/comments/hg0fx/a_modest_proposal_absolutely_no_babies_involved/+
http://www.opensecuritytraining.info/IntroX86.html

Note: send a thank you to https://prezi.com/a5tm-lf0879-/reverse-engineering-101-nyupoly-2010/

http://www.windbg.org/
https://code.google.com/archive/p/windbgshark/
https://www.scribd.com/doc/32327741/IDA-User-Tutorial
https://en.wikibooks.org/wiki/X86_Disassembly/Windows_Executable_Files

SUPER QUICK BURN THROUGH ON x86 ASSEMBLY:
https://www.youtube.com/watch?v=75gBFiFtAb8

+------------+
|   Twitter  |
+------------+

https://twitter.com/alfiedotwtf/status/726717041374187520

+-------+
|Xylitol|
+------++

crackmes.de
http://crackmes.de/users/xylitol

+------+
|Ro0ted|
+------+

https://archive.cyberguerrilla.org/a/2015/index.html%3Fp=1060.html
https://archive.cyberguerrilla.org/a/2015/index.html%3Fp=1100.html
https://archive.cyberguerrilla.org/a/2015/index.html%3Fp=1889.html

+-------------+
|Disassemblers|
+-------------+

http://reverseengineering.stackexchange.com/questions/1817/is-there-any-disassembler-to-rival-ida-pro
http://www.heaventools.com/PE_Explorer_disassembler.htm
http://www.hiew.ru/
http://www.hopperapp.com/
https://github.com/joelpx/plasma
http://decompilation.info/
https://www.onlinedisassembler.com/static/home/
https://github.com/wisk/medusa

+------------------------------------------+
|OpenSecurityTraining -Intro to x86 (2010) |
+------------------------------------------+

Link to course playlist:
https://www.youtube.com/watch?v=H4Z0S9ZbC0g&index=1&list=PL038BE01D3BAEFDB0

Link to course information/downloads: 
http://www.opensecuritytraining.info/IntroX86.html

Direct Content:
http://www.opensecuritytraining.info/IntroX86_files/IntroX86_all_materials_with_ppt.zip

CMU Linux Example:
http://http//csapp.cs.cmu.edu/2e/bomb32.tar

--- Day 1, Part 1 ---

9:30 - Decimal / Binary / Hex table - memorize it

10:00 - Negative Numbers (x01 - 0x7F positive byte, 0x80 to 0xFF negative byte <-- this probably isn't relevant

FF => 255 (why?) -> http://forum.renoise.com/index.php/topic/43402-hexadecimal-how-does-ff-255/

Intel is CISC -> Complex Instruction Set Computer
Variable length instructions, between 1 & 16 bytes long - 16 is max length in theory

RISC -> Reduced Instruction Set Computer
- More registers, less & fixed size instructions
- PowerPC, ARM, SPARC, MIPS

Architecture - Endian
- Gulliver's Travels

- Little Endian - 0x12345678 stored in RAM "little end first". Least significant byte of a word or larger is stored in the lowest address e.g. 0x78563412
- Intel is Little Endian
**- Registers store data as normal values, RAM stores Little Endian**

Big Endian - 0x12345678 stored as is
- Network traffic is big Endian
- Most everyone (PowerPC, ARM, SPARC) is Big Endian by default

Endianess -> 20:00

- Registers are small storage built into processor
- 8 general purposes registers + the instruction pointer which points at the next instruction to execute
- Two of 8 are not that general (instruction pointer)
- On x86-32, registers are 32 bits long
- On x86-64, they are 64 bits

(Book: )

Register Conventions -> 24:00

Intel's suggestions to developers. Registers don't have to be used these ways.
If compiler uses these conventions, easier to understand

EAX - Stores function return values, accumulator register [gr]
EBX - Base pointer to the data section [red]
ECX - Counter for string & loop operations [gr]
EDX - hardwareI/O pointer [red]

Intel Architecture Reference - Section 3.4.1 - General Purpose Registers

ESI - Source pointer for string operations
EDI - Destination pointer for string operations
ESP - Stack pointer
EBP - Stack frame base pointer
EIP - Pointer to next instruction to execute ("instruction pointer")

32:00

Caller-Save Registers -
EAX
EDX
ECX

-> If caller has anything in register it cares about, the caller is in charge of saving the value before a call to a subroutine & restoring the value after the call returns.

-> The callee can (and highly likely to) modify values in caller-save registers

Callee-save Registers -
EBP
EBX
ESI
EDI

-> If callee needs to use more register than are saved by caller, callee is responsible for making sure values are stored/restored.
-> Callee must be good & not modify registers which the caller didn't save unless callee itself saves & restores existing values

34:00

8/16/32 bit addressing 1
(Smaller forms of registers)
EAX -> AX [AH, AL]
ECX -> CX [CH, CL]
EDX -> DX [DH, DL]
EBX -> BX [BH, BL]

37:00

EFLAGS

May hold single bit flags
- Zero Flag (ZF) set if the result of some instruction is zero, cleared otherwise
- Sign Flag (SF) - Set equal to the most-significant bit of the result, which is the sign bit of a signed integer.
(0 indicates a positive value & 1 indicates a negative value)

**Instructions**

NOP - No Operation - No registers, no values, no nothing.
-> Just there to pad or align bytes, delay time
-> Bad guys use it to make simple exploits more reliable. Different class

NOP is an alias mnemonic for XCHG (E)AX, (E)AX instruction
XCHNG -> exchanges values in a set of values/instructions
Jon Erickson*

The Stack
-> Conceptual area of RAM designated by the Operating System when program started.
-> Different OSes start at different addresses by convention
-> Stacks are Last In First Out (LIFO/FILO) data structure
-> Data is pushed on to the top of stack, "popped" off before you get to anything else
-> Convention, stack grows toward lower memory addresses. Adding something to the
-> stack means the top of the stack is now at a lower memory address.

-> ESP points to top of stack, lowest address which was being used
--> While data will exist at addresses beyond top of stack, this is considered undefined

-> Stack keeps track of which functions were called before the current one, it holds local variables
-> frequently used to pass arguments to the next function to be called
-> A firm understanding of what is happening in the stack is *essential* to understanding operation

Push - DWord, word, quadword onto stack

-> For class purposes, will always be DWORD (4bytes)
-> Can be immediate numeric constant or a value in a register
-> Push instruction automatically decrements the staack pointer, ESP, by 4

Pop - Pop a value from the stack
-> Take a DWORD off the stack, put it in the register & increment ESP by 4

Calling Conventions

How code calls a subroutine is compile-dependent & configurable- there are some conventions
Only dealing with cdecl & stdcall conventions - there are many on wiki

Wiki x86 calling conventions
programmer's heaven calling conventions

CDECL
-> C declaration - most common convention
-> Function parameters pushed onto stack right to left (?)
-> Saves old stack frame pointer & sets up new stack frame
-> EAX or EDX:EAX returns result for primitive data types
-> **Caller** is responsible for cleaning up the stack

stdcall
-> Microsoft C++ Code / Win32 API
-> Function parameters pushed right to left
-> Saves old stack frame pointer & setup new stack frame
-> EAX or EAX:EDX
-> **Callee responsible for cleaning up any stack parameters it takes
-> "If I call my new way of doing stuff 'standard' it must be true!

Call - Call Procedure
-> Call's job transfer control to a different function, control can be resumed where left off
-> First pushes the address of next instruction onto stack
-> For use by RET when procedure is done
-> Changes EIP to the address given in the instruction
-> Destination address can be specified in multiple ways:
-->Absolute or relative address (relative to end of instruction)

RET -Return from Procedure
Two forms:
-> Pop top of the stack into EIP -> Pop increments stack pointer
--> In this form, instruction is written as "RET"
--> Typically used by cdecl functions

->Pop top of the stack into EIP & add constant number of bytes to ESP
--> Instruction is written as RET 0x8 or RET 0x20
--> Typically used by stdcall functions

MOV - Move
Can move:
-> Register to Register
-> Memory to Register, Register to Memory
-> Immediate to Register, Immediate to Memory

**NEVER** Memory to Memory
Memory addresses are given in r/m32 form talked about later

1:25:00 - Example1.c 

--- Day 1, Part 2 ---

30:00 - 2008 Express Edition

Creating a Binary

Example1 -> Set as Startup Project
Right Click -> Source files -> Add New Item ->C++ File -> Example1.c -> Add

Text copied from slide 51 of Example1.c from previous session - see source files

1:18:00 - r/m32 addressing forms

1:23:00 - LEA - Load Effective Address

1:24:00 - ADD - SUB functions






+------------------------------------------------------+
|OpenSecurityTraining - Reverse Engineering (2010-2014)|
+------------------------------------------------------+

Class Texts:
“Reversing: Secrets of Reverse Engineering” by Eldad Eilam
“The IDA Pro Book” by Chris Eagle


2011 YR Playlist:
https://www.youtube.com/watch?v=byK0tXH5axQ&list=PL416CEDF4A931DB0D&index=1

2013 YR Playlist:
https://www.youtube.com/watch?v=hqQZ6RR8cB4&list=PLUFkSN0XLZ-nXcDG89jS9iqKBnNHmz7Qw&index=3

2014 YR Playlist:


Direct Content (2014) -- password is "reclass2014":
http://www.opensecuritytraining.info/IntroductionToReverseEngineering_files/reclass_2014_1.zip

Direct Content (2013) -- password is "reclass2013":
http://www.opensecuritytraining.info/IntroductionToReverseEngineering_files/reclass_2013_1.zip
http://www.opensecuritytraining.info/IntroductionToReverseEngineering_files/2013IntroRE.pdf

Direct Content (2011) -- password is "reclass2011":
http://www.opensecuritytraining.info/IntroductionToReverseEngineering_files/reclass_public2.zip

All playlist Content:
http://www.opensecuritytraining.info/IntroductionToReverseEngineering.html

Links of Interest:
http://www.hep.wisc.edu/~pinghc/x86AssmTutorial.htm
http://www.cs.virginia.edu/~evans/cs216/guides/x86.html

--- Begin Notes ---




--- End Notes ---

+------------------------------------------------------+
|OpenSecurityTraining - Reverse Engineering Malware    |
+------------------------------------------------------+

Webpage: http://www.opensecuritytraining.info/ReverseEngineeringMalware.html

Class Texts:
“Practical Malware Analysis” by Michael Sikorski and Andrew Honig

Direct Content (2014):
http://www.opensecuritytraining.info/ReverseEngineeringMalware_files/malware_analysis_all_materials_2014-09-08_1.zip

Direct Content (2013):
http://www.opensecuritytraining.info/ReverseEngineeringMalware_files/REMalwareAll_2013-05-29.zip

Playlist:
http://www.opensecuritytraining.info/ReverseEngineeringMalware_files/REMalwareAll_2013-05-29.zip

--- Begin Notes ---




--- End Notes ---


+---------------+
|NYU Poly RE 101|
+---------------+

https://vimeo.com/6764570
https://prezi.com/a5tm-lf0879-/reverse-engineering-101-nyupoly-2010/

Andrew Kushman -> $1 million dollars per vulnerabilty

Homebrew patches - Adobe takes time to patch. 
Individuals release their own patches to fix something before vendors.
"Eliteness" factor

Patch analysis
->Reversing Microsoft Patches
->1st with a new exploit or 
->1st with new signature for scanners
-> Vuln Wednesday

Metasploit , Immunity
Vulnerability Analysis

RE is not always about the assembly
You are understanding the system & components
-> OS
-> Software
-> Hardware
-> Plane, train, automobile, anything

Reverse the system as a whole, get inside the developer's head
Reverse engineer intentional behavior

General steps, pre-disassembly
-> Examine System Behavior
-> Enumerate Components
-> Determine Relationships
-> Determine Trust
-> Locate & Probe Issues

Many tools aid in these steps:
Examining System Behavior -> Documentation
INstall & use the product - be a Sysadmin for the product
Support forums - expoitable bugs, dr. watson & process name

Product pre-requisites

MSRPC (Remote Procedure Call) <-- bad juju
-> Process Explorer
-> rpcdump, rpcinfo
-> mIDA

ActiveX, Codecs, File Formats, Protocol Handlers (uri:// aim:// adobebridge://)
-> RegMon
-> FileMon
-> ProcessMon
-> Services

**This was a talk from 2010 or so. Still talking about ActiveX, seriously?
It isn't relevant anymore.**

Named Pipes, RPC over named pipes

mIDA from Tenable
Takes process, gives you all MSRPC functions from a binary
Plugins -> mIDA in IDAPro
Shows the operands that a MSRPC can take in - can double click & will take you to the function
IDL (Interface Descriptor Language) -> mIDA <- allows you to talk to the protocol, pyMSRPC*

-> Registered Codecs
-> VMware Installs a video codec

IDefenseLabs -> ActiveX Controls

Locating & Probing Inputs

Create your own 'clients'
MSPRC -> Impacket (Core)
ActiveX -> COMRaider (David)
Verisign iDefense
TCP/UDP -> Socket Code

Subverting client code -> Python -> CTypes <- calling addresses / functions from another modules

IDAPro is the shit

Modules
process.exe, library.dll

Functions
At least one basic block can be called

Basic Block
Groups of instructions terminated

Instructions
mov, push, pop

*Graphing*

Code can be represented as a graph
Graphing traversal code is applicable here
Assuming no dynamic transfers

Graphic Tricks
-> Reachability (Functions, Basic blocks)
Upgraph/Downgraph/Intersection
Discover new vectors for attack
Discover paths to interesting code

Locate recursive functions programmatically
Loop detection
Binary diffing (BinDiff from Zynamics)

Intersection Graph (can be done in IDA)-> "Get me to every function that calls that function"
IDAPython

*ToorCon -> Reverser's Cookbook* <-- Aaron 

Intro to binary data structures

Objects (think object oriented, C++...)
@ecx
Constructors
Destructors
Function Tables, Methods
Inheritance

Variables -> Local, Global
Structures
Defined on Heap vs Stack
Important for exploitation

'Crossreferencing' How many times is this variable used? IDAPro

IDA Pro

FLIRT -> locate standard functions from an API inline to the executeable 

Strings
->assert calls
-> debug functions
-> Symbols

(view -> open sub view -> calls)

Cross Referencing
Imports/Exports
Segments

IDA SDK, IDC, IDAPython, IDA Debugger
Plugins
Automated Analysis (we'll get into this)

Static Analysis

Important to locate sources of user input
No runtime info available (besides ...)

Cross referencing & graphing is key 
C++ can make this frustrating

Pattern matching is helpful

IDC/IDAPython
'Find me all movsx'
Find me all add reg32,
Loop detection
Unsafe library calls
->cpy
->alloc

Dynamic Analysis

Breakpoints allow for jump start on analysis
e.g. Memory breakpoint on recv() buffer

Ability to resolve...
Object structure & relationships
Type Information
Input from other processes/systems/configs...
Global Variables

**Ability to populate .idb with runtime information**

**Crucial to exploit development**
e.g. Analyze heap layout dynamically

WinDBG -> heap walking, integrity checks. kernels.
cons: steep learning curve, poor plugin API

OllyDBG -> Intuitive
cons: Flakey Symbol Support, Supports 32-bit, Default install exposes expoitable vulnerabilities.
There's a function in Windows called Output ...

PyDBG -> Scriptable & easily extensible
Cons: Python is slow. 32-bit. Event based

IDA Debugger -> Contains 9 debugger engines -> Built-In to IDA
cons: multiple module support can be tricky to get the hang of. UI is sketchy


+---------------+
|NYU Poly RE 102|
+---------------+

https://vimeo.com/30594548
https://prezi.com/e5a2tumdqocj/reverse-engineering-102-nyupoly-2010/

Vulnerability Discovery, Analysis, Software DRM -> Limited understanding of target as a whole
WinGraph

Linker
Loader

Static is painful

Lexer/Parser/Renderer (QuickTime, Shockwave, Windows Media Player, Flash)

Input -> Header -> This version -> Chunks of a function -> Output -> Display

Module Dependencies

ws2_32.dll -> "network stuff"

Dependency Walker

WinDBG - > Attach a process
Less invasive
Load Process from start -> Loads different memory manager*
Large white screen
Register values are at a bottom of debugger
efl -> current flags
eip/int 3 -> current instruction

g -> go command. let's process run. CTRL+Break will interrupt it
r -> show current register contents & disassemby at current eip
.hh -> brings up WinDBG help

t -> trace steps one instruction and will step into functions
tc -> "step until call"
p -> single-steps one instruction and will step _over_ functions
pt -> step until return

WinDBG.org -> Symbols <- Symbol servers (Microsoft, Apple, Chrome Citrix)
microsoft.com/download/symbols

Gives you the call stack functions pulled from common modules*

x -> examine symbols
ln -> list nearest symbol
dt -> display type <- gives you values of address values
lm -> shows listed modules
lmm -> search with modules
!lmi -> more detailed info

any command that starts with a bang (!) will give extended info

Avoid STDs -> stdlibs
sx -> set exceptions
-> sxe ld:modulename
-> available via GUI debug -> event filters...

To prevent symbol lookup, prefix registers with @

eg r @eax as function names

You can reference addresses multiple ways:
* Address ( explicit 16 base number )
* Module Name ( OLEAUT32)
* Symbol w/ Module (OLEAUT32!DisCallFunc)
* Offsets (OLEAUT32!DisCallFuncx0320)

Viewing Memory

dd target - dump double words
dw target - dump words
db target - dump bytes
dc target - dump data & ASCII
da target - dump ASCII string
du target - dump UNICODE strings

k - view call stack
-> variations can give you arguments (kv)

Breakpoints

Software
-> bp target
-> bm target

Hardware
-> ba r1 target
-> ba e1 target
-> ba w4 target

Inserts an int 3 (Interrupt), stops the program.
Read, write or execute.
1,2,4 bytes on hardware target. "Break on access"

Conditional bp
bp address expression

bc -> clear breakpoint *
bd -> disable "
be -> enable "
bl -> list breakpoints

Breakpoint on smart things , e.g. API documentation -> WSARecv*

!heap Extension

!heap 0 -v -> walk main heap
!heap -p -a target -> user stack trace database - call stack for an allocation pointed to by target
Global Flags -> gflags for debugging Windows

+----------------+
|NYU Poly RE 103?|
+----------------+

https://vimeo.com/30076325

Taking an x86 binary back into C source code

->x86 ASM in 10 minutes
->Compiler Design & Code Optimizations
->Binary RE
->IDA PRO

1 32bit int sits in the register

ebp --> stack
esp --> stack

heap data

eip (instruction pointer) --> code

Arithmetic Instructions::

mov eax, 2 ; eax = 2
mov ebx, 3 ; ebx = 3
add eax, ebx ; eax = eax + ebx
sub ebx, 2 ; ebx = ebx -2

Accessing Memory::

mov eax, [1234] ; eax = *(int*)1234
mov ebx, 1234   ; ebx = 1234
mov eax, [xbx]  ; eax = *ebx
mov [ebx], eax  ; *ebx = eax


Conditional Branches::

cmp eax, 2  ; compare eax with 2

je label1   ; if (eax == 2) goto label1
ja label2   ; if (eax > 2)  goto label2
jb label3   ; if (eax < 2)  goto label3
jbe label4  ; if (eax <=2)  goto label4
jne label5  ; if (eax != 2) goto label5

jmp label6  ; unconditional goto label6

Function Calls::

call func ; store return address on stack & jump to function

func:
push esi ; save esi
...
pop esi ; restore esi
ret ; read return address from stack & jump to it

Modern compile architecture::

C code -> Intermediate representation -> Low level representation -> x86 Assembly
Parsing -> Optimization -> Register Allocation

IDA Pro -> The IDA Pro Book

You can rename functions in IDA pro & it will propogate throughout the rest of the program.

"Imports" tab will show you all foreign functions imported into the program.

Double clicking on any of the imports (CTRL+X) will bring up a cross reference of where the function is ...
being called from.

Function calls are highlighted in blue. On mouseover, text will show the function of the call.
Functions imported by another library are automatically named (WSAStartup, Win32_Main, etc)
Function names get lost unless you have symbols/public APIs available

Parameters to the functions are shown in the reverse order above the call, in the comments
When you call a function, it's arguments are pushed onto the stack.
Additional Push (EDI) may be used to save the arguments (values, data) into memory

return values are in the eax register

edi, eax (moves the eax to edi register)

'Green' branches are if a value is true (e.g. jnz -> TRUE) -> green path
'Red' branch is if the jnz condition is met, e.g. the value is -1 & errors out.

'Accept' function establishes a TCP connection / socket

 Pressing the semi colon adds a comment to the existing line

lea calculates the address of a variable, 

IDA allows you to rename registers

+-----------------+
|NYU Poly RE 101v2|
+-----------------+

https://prezi.com/a5tm-lf0879-/reverse-engineering-101-nyupoly-2010/

https://vimeo.com/15654318

+-----------------+
|NYU Poly RE 102v2|
+-----------------+

+-------------------------+
|NYU Poly Exploitation 101|
+-------------------------+

https://vimeo.com/16298629
https://vimeo.com/5146345

+-------------------------+
|NYU Poly Exploitation 102|
+-------------------------+

https://vimeo.com/16304711
https://vimeo.com/5160961

+--------------------+
|NYU Poly Fuzzing 101|
+--------------------+

https://vimeo.com/5236104
https://vimeo.com/5237484

+-----------+
|RE Binaries|
+-----------+

http://www.securitytube.net/video/1842

+-----------------+
|Windows Internals|
+-----------------+

https://vimeo.com/49347561

+----------------------------+
|Assembly Primer-SecurityTube|
+----------------------------+

https://www.youtube.com/watch?v=K0g-twyhmQ4

+-------+
|Ollydbg|
+-------+

http://www.ollydbg.de/quickst.htm

tuts4you reverse engineering with lena

* Set the god damn color scheme in the INI as followed here *
*** http://www.ollydbg.de/schemes.htm ***

+--------------------+
|reversingwithlena   |
+--------------------+

These are my general notes about these tutorials. These are the tuts4you reversing for newbites with lena content.
THe main download link is here:
https://tuts4you.com/download.php?list.17

Any passwords for this stuff is probably "tuts4you". Will need 7zip to unpiack these - WinRAR failed to unpack.
These resources are great, however, you will want to read these to understand the context of these guides & where
the failings come in with these. 

http://reversewithme.blogspot.com/2012/10/why-lena151-tutorials-wont-teach-you.html
http://lifeinhex.com/tag/lena151/

I've essentially transcribed the text notes from the flash files as best as possible.


+--------------------+
|reversingwithlena-01|
+--------------------+

Ollydbg is tool of choice. Familiar with shortcuts. Use the ini provided.

Ollydbg is a Ring3 debugger. Works at Windows application level, still can control other apps.
We can find 'bugs' in other programs.

Olly needs UDD path because breakpoints & other app info is stored there. 

Open ReverseMe

Upper right CPU main thread window

'VAs' -> Virtual addresses - when starting, loads app in certain memory location
(may not always be the same)

OpCodes -> "5A" blah blah blah" -> mnemonics (push eax, jmp, call)

Ollydbg comments to the right of the opcodes.

Pannel window on bottom before the hex shows any output.

2 digits => 1 byte
1 byte => 8 bits
1 opcode == 1 byte
2 bytes == 1 word
4 bytes == 1 dword
2 words == 1 dword (65 20 69 73)

download the help for APIs here:

tuts4you.com/request.php?258
tuts4you.com/request.php?1499

also need msu patch for win32 help file format

"Portable Executable File Format Compendium" by Goppit
gabri3l "Weakness of Windows API"

http://www.accessroot.com/arteam/site/download.php?list.10


Registers are on the right hand side
PCs always work in the hex system of data
Registers are placeholders for data

Assembly Information:

Windows PCs have 32bit registers (without flag registers)

eax - extended accumlator
ebx - extended base
ecx - extended counter
edx - extended data
esi - extended source index
edi - extended destination index
ebp - extended base pointer
esp - extended stack pointer
eip - extended instruction pointer

32bit => 4 bytes
can hold data from 0-FFFFFFFF (unsigned)

Most registers had main functions but now can be used for whatever you wish.

Although 32bit, some large parts (16 or 8bit) cannot be addressed directly.

[ 32 bit ][ 16 Bit ][ 8bit]
[eax][AX][AH/AL]
[ebx][BX][BH/BL]
[ecx][CX][CH/CL]
[edx][DX][DH/DL]
[esi][SI]
[edi][DI]
[ebp][BP]
[esp][SP]
[eip][Ip]

Example:

EDX == 7C90EB94
DX == EB94
DH == EB
DL == 94

See 'Basics of Assembler' doc in archive

Stack is lower right hand corner of file
Store things for later user
Stack is a basket, sheets are memory address by the point assignment
Last sheet of paper you put in stack is first you take out. 

push -> saves contents of a register into the stack
pop grabs last saved contents from stack & puts into register

Dump window -> OpCodes organized in rows/cols

Debuggers start at the EP -> Entry Point placing an INT3 (CC) instruction before the key files

F9 => Run

Code is executed top to bottom unless there is a jump (jmp) or calls in the code. 
Stepping into a program is called tracing.

Push is opposite of pop 
Stores vaue in stack & decrases by the size of the operand that was pushed so that ESP points
to the value that was PUSHed. 

Call -> Call something

Call pushes RVA (relative virtual adress) of instruction that follows to the stack
to know where to return after the call and then executes a sub routine

Call can be used as such:
call 4040000 (Call ADDRESS)
Call eax (Call register - executes the procedure with address == value of EAX)
Call dword ptr [EAX+5] executes procedure at address with value of EAX+5
Call <jmp to api> is also a call address but special as it executes an API

F7 -> Steps into code line by line
F8 -> Step over <- executes complete code in subroutines/calls

API GetModuleHandleA executes in ReverseMe

APIs run on Ring3 (high level) but use APIs to call to System Functions at Ring0 hence the need for APIs, that's how they 'talk' to each other

mov dest,src
mov copies value from src to destination & src stays where it was. 

variations of mov: movs/movsb/movsw/movsd, edi,esi

Variants copy byte/word/dword
ESI points to the space EDI points to.

MOVSX expands Byte or Word operands to Word or DWORD size & keeps sign of value
MOVZX expands Bye or WOrd operands to Word or DWORD size & fills rest of space with 0.

value of EAX ... is 004000000 (Reigsters) -> will be copied into DWORD starting at 402117 -> can be seen in value output pane.

Parameters of a function will be pushed into stack in reverse order so when pulled they come in regular order. 

"Access Generic_READ|Generic_write" -> Keyfile.dat

File no found leads to a crash ->

Cmp (Compare)

Cmp dest,src

Comp instruction compares two things and can set C/O/Z flags if the result fits.

Translated, EAX is compared to -1 (FFFFFFFF) so the comparison is true. 

Jumps/Jnz (Jump if not Zero) ZF=0 (z-flag) The result from the compare *IS* 0 in this reverseme (they are equal) so the jump will not be executed but badboy (e.g. the bad crash error) will still execute. 


Due to the INI file you will see the jump that will be executed if you have it enabled in the options.

Flags
32 different flags
Only need 3 usually in reversing
Z, O, C flags
ZOC -> this register is a collection of one bit flags. 
A flag is like a sign, green is OK, red is not ok. Flags can be set or not set.
Change the Z flag by double clicking on the value to jump past the error...
(?!)
Set breakpoints by presing F2 or double click on OpCodes

ReadFile tries to read keyfile.dat for certain bytes it puts into a buffer at $address$
hFile (read file) buffer is "FFFFFFFF" because there is no file instead of actual values

"Bytes to Read" -> 46h (70d) bytes. "at" "402173" to place them in a buffer at "40211A"

TEST operand1, operand2

TEST EAX,EAX

Performs logic (AND)  but doesn't save values. Only sets Z-flag

When EAX is - or it clears, when EAX is not 0. O/C flags are always cleared.

AND instruction (Logical And)

AND dest,src

AND uses logic on two values. Will clear O/C, can set Z-flag

1001010110
0101001101
----------
0001000100

When two "1" stand below, the result of the bit is 1. If not, the result is 0. You can use calc.exe to calculate AND values.

XOR dest,src

XOR connects two values using logical exclusive OR

Instruction clears O/C, can set Z-flag.

1001010110
0101001101
----------
1100011011

When two bits are top of each other are equal, the result bit is 0. Else, result bit is 1.

XOR EAX,EAX is most common. Will set EAX to 0 because when you XOR a value with itself, result is always 0.  This is always used to make sure a value is always zero.


Right click on "Comment" field" -> Search for -> "All referenced text strings" (equivalent of running strings.exe on a file.

Double clicking on a string will bring you to that file.
Jumps are displayed in the field below the CPU, but before the dump.

"Jump from..." will display where the jump occurs in address memory



"EIP" in the register is the current line to execute. If you get lost, double click it
004010BF -> change registers C, Z, S till "jump is taken"
"LJ" change the "S" reg to 0
double click to remove break points in the addresses
double click on the disassembly to change the OP assemble code
change Jnz to Jmp
Keep "Fill with NOPs" checked!!11
NOP = No Operation => "Do nothing"
JL Short reverseM. 004010C1 (?)

+--------------------+
|reversingwithlena-02|
+--------------------+

Olly by default comments code as best it can with common functions

Right click main CPU pain -> Analysis -> Analyse Code

"Anlyse this!" -> OllyDbg Plugin - > 

tuts4you.com/request.php?22

unzip into plugins directory- will show up in context menu

Understanding 8-bit Byte & Base-2 System

1011 -> 'base 2' because each number can be a 0 or a 1

For each placeholder, we multiply 2 to the placeholder power

(1*2^3) + (0*2^2) + (1*2^1) + (1*2^0)

8 + 0 + 2 + 1 = 11

8 bit collections -> byte

11111110 = 254
11111111 = 255

Byte values are used to hold individual characters in ASCII charset. Binary value between 0 to 127 is a specific character. 

*See Dec2Hex2Ascii.htm*


Values in assembly are represented with the number system as the ending value.

So, h at the end of a hex number, B (b) for binary, d(D) for Decimal

keyfile.dat

File not found: EAX=FFFFFFFFh
File is found:  EAX=00000040

48d == 30h == 0 ASCII


+------------+
|SecurityTube|
+------------+

Assembly Primer for Hackers (Part 1)
https://www.youtube.com/watch?v=K0g-twyhmQ4

(This video is a series. The playlist is cut out because the SecurityTube site is broken -- sort of)

+------------------------------------------+
|Putting knowledge to use - MicroCorruption|
+------------------------------------------+

Resources I have used for this CTF:
https://hackthissite.org/forums/viewtopic.php?f=37&p=79992&sid=58cb483c1effbae809224b91c1006c08
http://ghettohaxxx-blog.azurewebsites.net/microcorruption-ctf-writeup/
http://xgusix.com/blog/microcorruption-challenge-i/
http://opticaliqlusion.blogspot.com/2015/05/microcorruption-overflows-and-shellcode.html
http://ponies.io/posts/2014-09-16-microcorruption.html
https://destinaxe.wordpress.com/2015/02/08/microcorruption-ctf-hanoi/
https://destinaxe.wordpress.com/

Relevant Searches for more info/help:
https://www.google.com/search?num=50&q=mov.b+micro+corruption

About MicroCorruption:
https://microcorruption.com/about
https://microcorruption.com/manual.pdf

Books I rec'd from NCCGroup:
The Hacker Playbook
Web Application Hackers Book

Recommended Material:
"Practical Reverse Engineering", Bruce Dang, Alex Gazet, Elias Bachallany
"The C Programming Language", Brian Kernighan, Dennis Ritchie
"The shellcoders handbook", Chris Anley, John Heasman, Felix Linder, Gerardo Richarte

+--------------------------------+
|MicroCorruption Notes - Tutorial|
+--------------------------------+

+---------------------+
|MicroCorruption Notes|
+---------------------+

+---------------------+
|MicroCorruption Notes|
+---------------------+

+---------------------+
|MicroCorruption Notes|
+---------------------+

+---------------------+
|MicroCorruption Notes|
+---------------------+

+---------------------+
|MicroCorruption Notes|
+---------------------+

+---------------------+
|MicroCorruption Notes|
+---------------------+

